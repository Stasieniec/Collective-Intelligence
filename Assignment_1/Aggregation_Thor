from vi import Agent, Simulation, Config
from pygame.math import Vector2
import random
import math
import pygame as pg


class AggregationConfig(Config):
    delta_time: float = 0.5
    mass: int = 20  
    movement_speed: float = 1.0

    max_angle_change: float = 30.0
    p_change_direction: float = 0.1

    t_join_init: float = 100.0                  # The base time steps needed to stop
    t_join_noise: float = 25000.0               # The noise to add to the base time steps

    p_base_leaving: float = 0.5                 # The base probability for leaving 
    p_base_joining: float = 0.5                 # The base probability for joining 


class Particle(Agent):
    config: AggregationConfig

    def __init__(self, images, simulation, pos=None, move=None):
        super().__init__(images, simulation, pos, move)

        # Initialise move to a random angle
        if move is None:
            angle = random.uniform(0, 360)
            self.move = Vector2(self.config.movement_speed, 0).rotate(angle)

        # Initialise the state of the agent
        self.state = 'wandering'
        # Initialise the joining timer
        self.timer = 0

    def change_position(self):
        self.there_is_no_escape()  # The Agents teleport to the opposite side of the screen
        #self.wandering()  # Agent performs the walking/wandering behavior

        if self.state == 'wandering':           # Agent performs the walking/wandering behavior
            self.wandering()
        elif self.state == 'joining':           # Agent performs the joining behavior
            self.joining()
            self.wandering()
        elif self.state == 'still':             # Agent performs the still behavior
            self.still()

        # little pseudocode:
        # Wandering behavior
        # if is_in_site:
        #     if p_join:
        #         joining_behavior()
        #         if t_join:
        #             still_behavior()
        #             if p_leave:
        #                 leaving_behavior()
        #                 if t_leave:
        #                     wandering_behavior()

    def wandering(self):  
        '''
        Agent elicits random walking behaviour
        '''  
        # Probability to change direction
        if random.random() < self.config.p_change_direction:
            # Choose a random angle to rotate the current direction by
            angle_change = random.uniform(-self.config.max_angle_change, self.config.max_angle_change)
            # Rotate the move by the chosen angle
            self.move = self.move.rotate(angle_change)
        
        # Normalise move to keep the speed constant
        self.move = self.move.normalize() * self.config.movement_speed
        # Update the agent's position
        self.pos += self.move * self.config.delta_time


    def joining(self):
        '''
        timer for transitions from wandering to still based on t_join duration
        '''
    
        self.t_join = self.config.t_join_init + abs(random.gauss(0, self.config.t_join_noise))
        print(self.t_join)

        if self.timer > self.t_join:
            print("Still")
            self.state = 'still'
        else:
            self.timer += self.config.delta_time

    def joiningProbability(self, in_proximity):
        ''' 
        the more neighbours, the more chance of joining

        p_join = p_base * N

        '''
        neighbour_count = len(in_proximity)
        # Directly multiplying neighbour count with base probability
        p_joining = self.config.p_base_joining * (neighbour_count+1)
        return p_joining

    def still(self):
        self.freeze_movement()
        #self.wandering()

        in_proximity = self.in_proximity_accuracy().count()
        #for agent,dist in list(self.in_proximity):


    def leaving(self):
        pass

    def leavingProbability(self, in_proximity):
        '''
        the more neighbours there are, the less chance of leaving

        p_leave = p_base / N
        
        '''
        neighbour_count = len(in_proximity)
        # Dividing the base probability by the neighbour count to get the inverse
        p_leaving = self.config.p_base_leaving / (1 + neighbour_count)

        return p_leaving

    def update(self):
        return super().update()
    

class AggregationSimulation(Simulation):
    config: AggregationConfig

    def before_update(self):
        super().before_update()
        
        #temporarily testing the joining -> still functionality by pressing 'M'   
        for event in pg.event.get():
            if event.type == pg.KEYDOWN:
                if event.key == pg.K_m:
                    for agent in self._agents:
                        agent.state = "joining"


(
    AggregationSimulation(
        AggregationConfig(
            duration=10_000, 
            fps_limit=120,
            seed=1
        )
    )
    .batch_spawn_agents(10, Particle, images=["Assignment_0/images/green.png"])
    .run()
)
