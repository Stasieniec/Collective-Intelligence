from vi import Agent, Simulation, Config
from pygame.math import Vector2
import random
import pygame as pg
import math

'''
--------------+++++++++++ TO DO +++++++++++--------------
+++
++  Make so that when agent leaves the site, joining is reset,
        because at the moment the agents can stop outside the site
++
++  Include obstacle avoidance, so that the edge of screen is blocked 
        and so agents dont collide with eachother
++
++ 
++
++
+++
--------------+++++++++++++++++++++++++++++--------------
'''

class AggregationConfig(Config):
    delta_time: float = 0.5
    mass: int = 20  
    movement_speed: float = 1

    max_angle_change: float = 30.0              # The maximum angle to change direction into, small for smoothness
    p_change_direction: float = 0.1             # The probability of an agent changing direction, is small for smoothness

    t_join_base: float = 50.0                  # The base time steps needed to stop
    t_join_noise: float = 5.0                # The noise to add to the base time steps

    p_base_leaving: float = 0.1                # The base probability for leaving 
    p_base_joining: float = 0.5                # The base probability for joining 
    a: float = 0.6
    b: float = 2.6

    time_step_d: int = 40                      # The number of time steps before checking to leave

class Particle(Agent):
    config: AggregationConfig

    def __init__(self, images, simulation, pos=None, move=None):
        super().__init__(images, simulation, pos, move)

        if move is None:
            angle = random.uniform(0, 360)
            self.move = Vector2(self.config.movement_speed, 0).rotate(angle)

        self.state = 'wandering'
        self.timer = 0

    def change_position(self):
        self.there_is_no_escape()  # The Agents teleport to the opposite side of the screen

    def wandering(self):  
        if random.random() < self.config.p_change_direction:
            angle_change = random.uniform(-self.config.max_angle_change, self.config.max_angle_change)
            self.move = self.move.rotate(angle_change)
        
        self.move = self.move.normalize() * self.config.movement_speed
        self.pos += self.move * self.config.delta_time

    def joining(self):
        '''
        timer for transitions from wandering to still based on t_join duration
        '''
        self.wandering()  # Let the agent to keep moving

        if self.timer > self.t_join:
                self.state = 'still'
                print("State changed to still")
                
        else:
            self.timer += self.config.delta_time


    def joiningProbability(self, in_proximity):
        '''
        https://hal.science/hal-02082903v1/file/Self_organised_Aggregation_in_Swarms_of_Robots_with_Informed_Robots.pdf
        Pstay = 0.03 + 0.48 ∗ (1 − e −an);
        
        '''
        p_stay = 0.03 + 0.48 * (1 - math.exp(-self.config.a * (in_proximity + 1)))  
        return p_stay

    def still(self):
        self.freeze_movement()
        rand = random.random()
        in_proximity = self.in_proximity_performance().count()

        if AggregationSimulation.global_delta_time % self.config.time_step_d == 0:
            if rand < self.leavingProbability(in_proximity):
                self.state = 'leaving'
                self.continue_movement()

    def leaving(self):
        if self.checkInSite():
            if random.random() < self.config.p_change_direction:
                angle_change = random.uniform(-self.config.max_angle_change, self.config.max_angle_change)
                self.move = self.move.rotate(angle_change)

            self.move = self.move.normalize() * self.config.movement_speed
            self.pos += self.move * self.config.delta_time
        else:
            self.state = 'wandering'

    def leavingProbability(self, in_proximity):
        '''
        https://hal.science/hal-02082903v1/file/Self_organised_Aggregation_in_Swarms_of_Robots_with_Informed_Robots.pdf
        
        Pleave = e^−bn;
        '''

        return math.exp(-self.config.b*(in_proximity+1))

    def checkInSite(self):
        return self.on_site()

    def update(self):
        if self.state == 'wandering':
            self.wandering()
            if AggregationSimulation.global_delta_time % self.config.time_step_d == 0:
                if self.checkInSite() and random.random() < self.joiningProbability(self.in_proximity_performance().count()):
                    self.state = 'joining'
                    self.timer = 0
                    self.t_join = self.config.t_join_base + abs(random.gauss(0, self.config.t_join_noise))
        elif self.state == 'joining':
            self.joining()
        elif self.state == 'still':
            self.still()
        elif self.state == 'leaving':
            self.leaving()
        return super().update()

class AggregationSimulation(Simulation):
    config: AggregationConfig
    init_pos: Vector2 = Vector2(0, 0)

    global_delta_time: int = 0

    def before_update(self):
        super().before_update()
        AggregationSimulation.global_delta_time += 1
        for event in pg.event.get():
            if event.type == pg.KEYDOWN:
                if event.key == pg.K_m:
                    for agent in self._agents:
                        agent.state = "joining"

(
    AggregationSimulation(
        AggregationConfig(
            duration=10_000, 
            fps_limit=120,
            seed=1,
            movement_speed=1,
            radius=75
        )
    )
    .batch_spawn_agents(50, Particle, images=["Assignment_0/images/green.png"])
    .spawn_site("Assignment_0/images/bubble-full.png", x=375, y=375)
    .run()
)
